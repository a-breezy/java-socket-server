package com.ambrose.basics;

import java.util.ArrayList;		// reference to be able to use ArrayList. it lives in the built in java package java.util

								// note we don't import the Thread class - it's in the java.lang package, and you get that package for free,
								// don't need to import it.  The word import means kinda what it means - import the definition of this thing
								// "into this space" so I (Mr. Compiler) know what the heck you are talking about
public class DriverThreads {


	private static final String name = "DriverThreads";
	private static boolean exception;
	
		// This declaration / signature, is a magic signature, this is how Java knows/finds "the entry point" to the thing you want to execute.  
	public static void main(String [] args) {
		
		System.out.println("Starting " + name);
		
		// I would note in passing Java is a "strongly typed language".  Totally opposite from Javascript, which is totally not.
		// In Java you have to declare what the heck type your variables are.
		// This is to keep you out of trouble, so you don't try to do crazy stuff,
		// like try to take a fish for a walk on a leash, or put the dog in the fish tank.  Mr. Compiler says "no no no", you ain't making sense.
		
		ArrayList <Thread> workers = new ArrayList <Thread>(3);
		
			// Another note is, you don't typically use Threads a whole lot, in real life. Unless you are going to write something like a 
			// server, that is going to converse with a whole bunch of clients.
		
		try {
		
	        Thread worker = new WorkerThread();
	        workers.add(worker);       
	        worker.start();   
	        
	        worker = new WorkerThread();
	        workers.add(worker);       
	        worker.start(); 
	        
	        worker = new WorkerThread();
	        workers.add(worker);       
	        worker.start(); 
	        
	        // Most often when you are using threads, they are "inside something that is itself continually running" huh??? - Inside e.g. a
	        // server that runs all day.  You spawn a thread to handle the work generated by somebody connecting to your server. So
	        // you got 1000 people each running their own thread.
	        // Here we do not have "run all day".  If we did not have this join() thing here, this program would just
	        // "run right through" and it would be over before you saw a shred of output from the WorkerThread.  This program has no
	        // clue that "oh, I just started some threads, I should hang around for while till they finish.  This for loop, from
	        // stacktrace, does that
	        
        	for (int ix = 0; ix < workers.size(); ix++)
          	  workers.get(ix).join();

          	// 	https://stackoverflow.com/questions/1252190/how-to-wait-for-a-number-of-threads-to-complete
          	//		"Each join will block until the respective thread has completed.
          	//		Threads may complete in a different order than you joining them,
          	//		but that's not a problem: when the loop exits, all threads are completed."
		}
		catch(InterruptedException ee) {
			exception = true;
			ee.printStackTrace();			
		}
		catch (Exception e) {
			exception = true;
			e.printStackTrace();
		}
		
		System.out.println("End " + name);

		if (exception)
			System.exit(1);

		System.exit(0);
	}
}